------------------------------------------------------------------------------------------------------------------------------------
# BRONZE

-- CRIAÇÃO DO SCHEMA BRONZE
-- O schema 'bronze' funciona como a área de staging/landing, recebendo dados brutos, sem tratamento de tipos.
CREATE SCHEMA IF NOT EXISTS bronze;

-- Tabela BRONZE.contas_planejadas
-- Recebe dados brutos de contas planejadas. Campos de valor e data são mantidos como VARCHAR.
CREATE TABLE IF NOT EXISTS bronze.contas_planejadas (
    id_conta VARCHAR(50),
    data_vencimento VARCHAR(50),
    valor_previsto VARCHAR(50), 
    parceiro VARCHAR(100),
    categoria_financeira VARCHAR(100),
    status_cobranca VARCHAR(50)
);

-- Tabela BRONZE.transacoes_realizadas
-- Recebe dados brutos das transações realizadas.
CREATE TABLE IF NOT EXISTS bronze.transacoes_realizadas (
    id_transacao VARCHAR(50),
    data_lancamento VARCHAR(50),
    valor_transacao VARCHAR(50), 
    parceiro VARCHAR(100),
    categoria_financeira VARCHAR(100)
);

-- NOTA: Importe seus arquivos de origem (CSV, XLSX) diretamente para estas tabelas.
```


------------------------------------------------------------------------------------------------------------------------------------

# SILVER

-- 1. CRIAÇÃO DO SCHEMA SILVER
-- O schema Silver é a área de integração, onde as regras de qualidade e tipagem de dados são aplicadas.
CREATE SCHEMA IF NOT EXISTS silver;

-- 2. Tabela SILVER.contas_planejadas (Schema)
-- Dados limpos, com tipos corrigidos para evitar erros na inserção (NUMERIC/DATE).
CREATE TABLE IF NOT EXISTS silver.contas_planejadas (
    id_conta VARCHAR(50) PRIMARY KEY,
    data_vencimento DATE,             -- Tipo corrigido para DATE.
    valor_previsto NUMERIC(10, 2),    -- Tipo corrigido para NUMERIC.
    parceiro VARCHAR(100),
    categoria_financeira VARCHAR(100),
    status_cobranca VARCHAR(50)
);

-- 3. Tabela SILVER.transacoes_realizadas (Schema)
CREATE TABLE IF NOT EXISTS silver.transacoes_realizadas (
    id_transacao INTEGER PRIMARY KEY, -- Tipo corrigido para INTEGER.
    data_lancamento DATE,             -- Tipo corrigido para DATE.
    valor_realizado NUMERIC(10, 2),   -- Tipo corrigido para NUMERIC.
    parceiro VARCHAR(100),
    categoria_financeira VARCHAR(100)
);

-- 4. ETL BRONZE PARA SILVER: POPULAÇÃO E LIMPEZA (TRANSFORMAÇÃO)

-- a) Carga e Limpeza de Contas Planejadas:
-- Simula a limpeza de caracteres monetários e conversão para NUMERIC e DATE.
INSERT INTO silver.contas_planejadas
SELECT
    id_conta,
    data_vencimento::DATE,
    REPLACE(REPLACE(REPLACE(valor_previsto, 'R$', ''), '.', ''), ',', '.')::NUMERIC(10, 2),
    parceiro,
    categoria_financeira,
    status_cobranca
FROM bronze.contas_planejadas
ON CONFLICT (id_conta) DO NOTHING;

-- b) Carga e Limpeza de Transações Realizadas:
INSERT INTO silver.transacoes_realizadas
SELECT
    id_transacao::INTEGER,
    data_lancamento::DATE,
    REPLACE(REPLACE(REPLACE(valor_transacao, 'R$', ''), '.', ''), ',', '.')::NUMERIC(10, 2),
    parceiro,
    categoria_financeira
FROM bronze.transacoes_realizadas
ON CONFLICT (id_transacao) DO NOTHING;
```

------------------------------------------------------------------------------------------------------------------------------------

# GOLD

-- 1. CRIAÇÃO DO SCHEMA GOLD
-- O schema Gold é o modelo dimensional (Esquema Estrela) otimizado para o consumo no Power BI.
CREATE SCHEMA IF NOT EXISTS gold;

-- 2. Tabela Dimensão: gold.dim_tempo
-- FK para a Fato.
CREATE TABLE IF NOT EXISTS gold.dim_tempo (
    data DATE PRIMARY KEY,
    ano INTEGER NOT NULL,
    mes INTEGER NOT NULL,
    nome_mes VARCHAR(20) NOT NULL,
    dia_semana INTEGER NOT NULL,
    nome_dia_semana VARCHAR(20) NOT NULL
);

-- 3. Tabela Dimensão: gold.dim_conta
-- Dimensão de contas usada para agrupar e filtrar por tipo de conta.
CREATE TABLE IF NOT EXISTS gold.dim_conta (
    id_conta VARCHAR(50) PRIMARY KEY,
    descricao_detalhada VARCHAR(255),
    tipo_conta VARCHAR(50) 
);

-- 4. Tabela Fato: gold.ft_fluxo_caixa
-- Tabela Fato central, integra Planejado e Realizado.
CREATE TABLE IF NOT EXISTS gold.ft_fluxo_caixa (
    sk_fluxo_caixa SERIAL PRIMARY KEY,
    id_transacao INTEGER,
    id_conta VARCHAR(50) REFERENCES gold.dim_conta(id_conta),
    data_ref DATE REFERENCES gold.dim_tempo(data),
    
    valor_realizado NUMERIC(10, 2),
    valor_planejado NUMERIC(10, 2),
    valor_net NUMERIC(10, 2) NOT NULL, -- Métrica base para o cálculo DAX 'Valor Líquido Total'.
    
    tipo_movimento VARCHAR(10), 
    categoria VARCHAR(100),
    
    is_realizado BOOLEAN NOT NULL,  -- Flag usada na medida DAX 'Total Realizado'.
    is_planejado BOOLEAN NOT NULL,  -- Flag usada na medida DAX 'Total Planejado'.
    is_entrada BOOLEAN NOT NULL,
    is_saida BOOLEAN NOT NULL
);

-- 5. POPULAR gold.dim_tempo (Script Gerador de Datas)
DO $$
DECLARE
    start_date DATE := '2024-01-01'; 
    end_date DATE := '2026-12-31';   
BEGIN
    TRUNCATE TABLE gold.dim_tempo; 
    
    INSERT INTO gold.dim_tempo (data, ano, mes, nome_mes, dia_semana, nome_dia_semana)
    SELECT
        dt::DATE,
        EXTRACT(YEAR FROM dt) AS ano,
        EXTRACT(MONTH FROM dt) AS mes,
        TO_CHAR(dt, 'Month') AS nome_mes,
        EXTRACT(ISODOW FROM dt) AS dia_semana,
        TO_CHAR(dt, 'Day') AS nome_dia_semana
    FROM generate_series(start_date, end_date, '1 day'::interval) AS t(dt)
    ON CONFLICT (data) DO NOTHING;
END $$;

-- 6. LÓGICA DE CARGA SILVER PARA GOLD:

-- a) POPULAR gold.dim_conta: 
INSERT INTO gold.dim_conta (id_conta, tipo_conta, descricao_detalhada)
SELECT DISTINCT id_conta, 
       CASE WHEN valor_previsto > 0 THEN 'Receber' ELSE 'Pagar' END AS tipo,
       categoria_financeira
FROM silver.contas_planejadas
ON CONFLICT (id_conta) DO NOTHING;

-- b) POPULAR gold.ft_fluxo_caixa (Carga de Dados Planejados):
INSERT INTO gold.ft_fluxo_caixa (
    id_conta, data_ref, valor_planejado, valor_net, tipo_movimento, categoria,
    is_planejado, is_realizado, is_entrada, is_saida
)
SELECT 
    cp.id_conta,
    cp.data_vencimento,
    cp.valor_previsto,
    cp.valor_previsto,
    'Planejado' AS tipo_movimento,
    cp.categoria_financeira,
    TRUE AS is_planejado, 
    FALSE AS is_realizado,
    CASE WHEN cp.valor_previsto > 0 THEN TRUE ELSE FALSE END AS is_entrada,
    CASE WHEN cp.valor_previsto < 0 THEN TRUE ELSE FALSE END AS is_saida
FROM silver.contas_planejadas cp;

-- c) POPULAR gold.ft_fluxo_caixa (Carga de Dados Realizados):
INSERT INTO gold.ft_fluxo_caixa (
    id_transacao, id_conta, data_ref, valor_realizado, valor_net, tipo_movimento, categoria,
    is_planejado, is_realizado, is_entrada, is_saida
)
SELECT 
    tr.id_transacao,
    tr.id_conta,
    tr.data_lancamento,
    tr.valor_realizado,
    tr.valor_realizado,
    'Realizado' AS tipo_movimento,
    tr.categoria_financeira,
    FALSE AS is_planejado,
    TRUE AS is_realizado, 
    CASE WHEN tr.valor_realizado > 0 THEN TRUE ELSE FALSE END AS is_entrada,
    CASE WHEN tr.valor_realizado < 0 THEN TRUE ELSE FALSE END AS is_saida
FROM silver.transacoes_realizadas tr;
```
